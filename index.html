<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Siatka odwiedzonych kwadratów</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .panel {
      position: absolute;
      top: 12px; left: 12px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      padding: 10px 12px;
      font: 14px/1.3 system-ui, sans-serif;
    }
    .panel label { display: flex; align-items: center; gap: 8px; margin: 6px 0; cursor: pointer; }
    .btn {
      display: inline-block;
      border: none;
      border-radius: 10px;
      padding: 8px 10px;
      margin: 2px 0;
      background: #1f6feb;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 4px 14px rgba(31,111,235,0.35);
      font-size: 13px;
    }
    .btn.red { background: #d73a49; }
    .counter { margin-top:8px; font-size:13px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div style="font-weight:600; margin-bottom:6px;">Warstwy siatki</div>
    <label><input id="toggleBig" type="checkbox" checked /> Squadrats</label>
    <label><input id="toggleSmall" type="checkbox" checked /> Squadratinhos</label>
    <hr style="border:none; border-top:1px solid #e9e9e9; margin:8px 0;">
    <button id="locateBtn" class="btn">GPS</button>
    <button id="exportBtn" class="btn">Eksport</button>
    <input type="file" id="importFile" accept=".geojson,.json" style="display:none;" />
    <button id="importBtn" class="btn">Import</button>
    <button id="resetBtn" class="btn red">Wyczyść</button>
    <div class="counter" id="counter"></div>
  </div>

  <script>
    const map = L.map('map').setView([52.2297, 21.0122], 12);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>'
    }).addTo(map);

    const bigGridLayer = L.layerGroup().addTo(map);
    const smallGridLayer = L.layerGroup().addTo(map);

    const bigStyle = { color: '#1f6feb', weight: 2.5, opacity: 0.9, fillOpacity: 0 };
    const smallStyle = { color: '#37c46a', weight: 0.8, opacity: 0.8, fillOpacity: 0 };

    // odwiedzone kwadraty
    const visitedBig = new Set(JSON.parse(localStorage.getItem('visitedBig') || "[]"));
    const visitedSmall = new Set(JSON.parse(localStorage.getItem('visitedSmall') || "[]"));

    function saveVisited() {
      localStorage.setItem('visitedBig', JSON.stringify([...visitedBig]));
      localStorage.setItem('visitedSmall', JSON.stringify([...visitedSmall]));
    }

    function drawGrid(zRef, layer, style, visitedSet, fillColor, strong=false) {
      layer.clearLayers();
      const bounds = map.getBounds();
      const nw = map.project(bounds.getNorthWest(), zRef);
      const se = map.project(bounds.getSouthEast(), zRef);
      const tileSize = 256;
      const startX = Math.floor(nw.x / tileSize) * tileSize;
      const startY = Math.floor(nw.y / tileSize) * tileSize;
      const endX   = Math.ceil(se.x / tileSize) * tileSize;
      const endY   = Math.ceil(se.y / tileSize) * tileSize;

      let total = 0, visitedCount = 0;

      for (let x = startX; x < endX; x += tileSize) {
        for (let y = startY; y < endY; y += tileSize) {
          total++;
          const id = `${zRef}-${x}-${y}`;
          const pNW = L.point(x, y);
          const pSE = L.point(x + tileSize, y + tileSize);
          const llNW = map.unproject(pNW, zRef);
          const llSE = map.unproject(pSE, zRef);

          const rect = L.rectangle([llNW, llSE], {
            ...style,
            fillColor: visitedSet.has(id) ? fillColor : undefined,
            fillOpacity: visitedSet.has(id) ? (strong ? 0.55 : 0.3) : 0
          });

          if (visitedSet.has(id)) visitedCount++;
          layer.addLayer(rect);
        }
      }
      return { total, visitedCount };
    }

    function scheduleRedraw() {
      requestAnimationFrame(() => {
        const bigStats = drawGrid(14, bigGridLayer, bigStyle, visitedBig, '#1f6feb');
        const smallStats = drawGrid(17, smallGridLayer, smallStyle, visitedSmall, '#15803d', true);

        document.getElementById("counter").textContent =
          `Duże: ${bigStats.visitedCount}/${bigStats.total}  |  Małe: ${smallStats.visitedCount}/${smallStats.total}`;
      });
    }

    scheduleRedraw();
    map.on('moveend zoomend resize', scheduleRedraw);

    document.getElementById('toggleBig').addEventListener('change', e => {
      e.target.checked ? bigGridLayer.addTo(map) : map.removeLayer(bigGridLayer);
    });
    document.getElementById('toggleSmall').addEventListener('change', e => {
      e.target.checked ? smallGridLayer.addTo(map) : map.removeLayer(smallGridLayer);
    });

    function getTileIdForLatLng(latlng, zRef) {
      const p = map.project(latlng, zRef);
      const tileSize = 256;
      const x = Math.floor(p.x / tileSize) * tileSize;
      const y = Math.floor(p.y / tileSize) * tileSize;
      return `${zRef}-${x}-${y}`;
    }

    let watchActive = false;
    let userMarker, userCircle;
    let firstLocation = true;

    document.getElementById('locateBtn').addEventListener('click', () => {
      if (watchActive) {
        map.stopLocate();
        watchActive = false;
        return;
      }
      if (!navigator.geolocation) return;
      map.locate({ watch: true, maxZoom: 17, enableHighAccuracy: true, setView: false });
      watchActive = true;
      firstLocation = true;
    });

    map.on('locationfound', e => {
      const { latlng, accuracy } = e;
      if (firstLocation) {
        map.setView(latlng, 16);
        firstLocation = false;
      }

      if (userMarker) map.removeLayer(userMarker);
      if (userCircle) map.removeLayer(userCircle);
      userMarker = L.marker(latlng).addTo(map);
      userCircle = L.circle(latlng, { radius: accuracy, color: '#1f6feb', weight: 1 }).addTo(map);

      // oznaczamy odwiedzone
      const bigId = getTileIdForLatLng(latlng, 14);
      const smallId = getTileIdForLatLng(latlng, 17);

      let changed = false;
      if (!visitedBig.has(bigId)) { visitedBig.add(bigId); changed = true; }
      if (!visitedSmall.has(smallId)) { visitedSmall.add(smallId); changed = true; }

      if (changed) {
        saveVisited();
        scheduleRedraw();
      }
    });

    map.on('locationerror', e => console.warn('Błąd geolokalizacji:', e.message));

    // Ręczne zaznaczanie małych kwadratów (dwuklik)
    map.on('dblclick', (e) => {
      const smallId = getTileIdForLatLng(e.latlng, 17);
      if (!visitedSmall.has(smallId)) {
        visitedSmall.add(smallId);
        saveVisited();
        scheduleRedraw();
      }
    });

    // Eksport GeoJSON
    document.getElementById('exportBtn').addEventListener('click', () => {
      const features = [];

      for (let id of visitedBig) {
        const [z,x,y] = id.split("-").map(Number);
        features.push(tileToPolygon(x,y,z,"big"));
      }
      for (let id of visitedSmall) {
        const [z,x,y] = id.split("-").map(Number);
        features.push(tileToPolygon(x,y,z,"small"));
      }

      const geojson = { type: "FeatureCollection", features };
      const blob = new Blob([JSON.stringify(geojson,null,2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "visited-squares.geojson";
      a.click();
      URL.revokeObjectURL(url);
    });

    // Import GeoJSON
    document.getElementById('importBtn').addEventListener('click', () => {
      document.getElementById('importFile').click();
    });

    document.getElementById('importFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const data = JSON.parse(evt.target.result);
          if (data.type === "FeatureCollection") {
            let changed = false;
            data.features.forEach(f => {
              if (f.properties?.grid === "big") {
                visitedBig.add(f.id); changed = true;
              } else if (f.properties?.grid === "small") {
                visitedSmall.add(f.id); changed = true;
              }
            });
            if (changed) {
              saveVisited();
              scheduleRedraw();
            }
          }
        } catch (err) {
          console.error("Błąd przy imporcie GeoJSON:", err.message);
        }
      };
      reader.readAsText(file);
    });

    // Reset odwiedzonych
    document.getElementById('resetBtn').addEventListener('click', () => {
      visitedBig.clear();
      visitedSmall.clear();
      saveVisited();
      scheduleRedraw();
    });

    // Zamiana kafelka na poligon GeoJSON
    function tileToPolygon(x,y,z,type){
      const pNW = L.point(x,y);
      const pSE = L.point(x+256,y+256);
      const llNW = map.unproject(pNW, z);
      const llSE = map.unproject(pSE, z);
      const llNE = L.latLng(llNW.lat, llSE.lng);
      const llSW = L.latLng(llSE.lat, llNW.lng);

      return {
        type:"Feature",
        id:`${z}-${x}-${y}`,
        properties:{grid:type},
        geometry:{
          type:"Polygon",
          coordinates:[[
            [llNW.lng,llNW.lat],
            [llNE.lng,llNE.lat],
            [llSE.lng,llSE.lat],
            [llSW.lng,llSW.lat],
            [llNW.lng,llNW.lat]
          ]]
        }
      };
    }
  </script>
</body>
</html>
